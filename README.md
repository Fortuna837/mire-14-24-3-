# Анализ алгоритмов сортировки и поиска

## Алгоритмы сортировки

### Сортировка выбором (Selection Sort)

**Определение:**  
Алгоритм, который последовательно строит отсортированную часть массива, начиная с начала. На каждом шаге в неотсортированном сегменте отыскивается наименьший элемент, который затем перемещается в конец упорядоченной области.

**Анализ:**
- **Внешний цикл** (`for (int i = 0; i < n - 1; i++)`) выполняется `n-1` раз, так как последний элемент автоматически займет свою позицию
- **Внутренний цикл** (`for (int j = i + 1; j < n; j++)`) на каждой итерации внешнего цикла просматривает `n-i-1` элементов
- **Операция сравнения** (`if (arr[j] < arr[minIndex])`) выполняется внутри внутреннего цикла для поиска минимального элемента
- **Операция обмена** (`swap(arr[i], arr[minIndex])`) выполняется ровно один раз за каждую итерацию внешнего цикла

**Временная сложность:**  
O(n²)

**Объяснение временной сложности:**  
Количество сравнений составляет: `(n-1) + (n-2) + ... + 1 = n(n-1)/2`, что соответствует O(n²). Количество обменов всегда равно `n-1`, что составляет O(n). Доминирующей операцией являются сравнения, поэтому общая сложность - квадратичная.

---

### Сортировка пузырьком (Bubble Sort)

**Определение:**  
Простой алгоритм, который многократно проходит по списку, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке.

**Анализ:**
- **Внешний цикл** (`for (int i = 0; i < n - 1; i++)`) выполняется `n-1` раз, обеспечивая необходимое количество проходов по массиву
- **Внутренний цикл** (`for (int j = 0; j < n - i - 1; j++)`) на каждой итерации проходит от начала до `n-i-1`, попарно сравнивая соседние элементы
- **Операция сравнения** (`if (arr[j] > arr[j + 1])`) выполняется для каждой пары соседних элементов во внутреннем цикле
- **Операция обмена** (блок с `temp`) выполняется только когда элементы находятся в неправильном порядке

**Временная сложность:**  
O(n²)

**Объяснение временной сложности:**  
Количество сравнений составляет: `(n-1) + (n-2) + ... + 1 = n(n-1)/2`, что соответствует O(n²). В худшем случае (обратно отсортированный массив) количество обменов также будет O(n²). Доминирующей операцией являются сравнения, поэтому общая сложность - квадратичная.

---

### Сортировка вставками (Insertion Sort)

**Определение:**  
Алгоритм, который последовательно берет каждый очередной элемент и вставляет его на нужную позицию в уже отсортированной части массива, сдвигая остальные элементы вправо.

**Анализ:**
- **Внешний цикл** (`for i in range(1, len(arr))`) выполняется `n-1` раз, начиная со второго элемента массива
- **Ключевой элемент** (`key = arr[i]`) сохраняет значение текущего элемента для последующей вставки
- **Внутренний цикл** (`while j >= 0 and arr[j] > key`) перемещается влево по отсортированной части, сдвигая элементы больше ключа
- **Операция сдвига** (`arr[j + 1] = arr[j]`) выполняется для освобождения места под ключевой элемент
- **Финальная вставка** (`arr[j + 1] = key`) помещает ключевой элемент в правильную позицию

**Временная сложность:**  
O(n²)

**Объяснение временной сложности:**  
В худшем случае (обратно отсортированный массив) внутренний цикл выполнит `1 + 2 + 3 + ... + (n-1) = n(n-1)/2` операций сравнения и сдвига, что соответствует O(n²). В лучшем случае (уже отсортированный массив) внутренний цикл не выполняется, что дает O(n).

---

### Сортировка слиянием (Merge Sort)

**Определение:**  
Алгоритм, основанный на парадигме «разделяй и властвуй». Он рекурсивно разбивает исходный массив на две половины, а затем сливает эти подмассивы в упорядоченном виде.

**Анализ:**
- **Рекурсивное разделение** (`mergeSort` вызывает себя дважды) делит массив пополам до достижения подмассивов размером 1
- **Функция слияния** (`merge`) создает два временных подмассива (`leftArr` и `rightArr`) и объединяет их в исходный массив в отсортированном порядке
- **Основной цикл слияния** (`while (i < leftArr.size() && j < rightArr.size())`) попеременно выбирает меньший элемент из двух подмассивов
- **Два завершающих цикла** копируют оставшиеся элементы из левого или правого подмассива
- **Требуется дополнительная память** O(n) для временных подмассивов

**Временная сложность:**  
O(n log n)

**Объяснение временной сложности:**  
Глубина рекурсии составляет O(log n) уровней, так как массив каждый раз делится пополам. На каждом уровне рекурсии выполняется операция слияния всех n элементов (функция `merge` работает за O(n)). Общая сложность: O(n) × O(log n) = O(n log n).

---

### Сортировка Шелла (Shell Sort)

**Определение:**  
Усовершенствованный вариант сортировки вставками, который сортирует элементы, находящиеся на определенном расстоянии друг от друга. Шаг постепенно уменьшается до единицы.

**Анализ:**
- **Внешний цикл** (`while gap > 0`) управляет последовательным уменьшением шага `gap` от `n//2` до 1
- **Средний цикл** (`for i in range(gap, n)`) проходит по всем элементам, начиная с позиции `gap`
- **Внутренний цикл** (`while j >= gap and arr[j - gap] > temp`) выполняет сортировку вставками внутри подмассивов с шагом `gap`
- **Операция сдвига** (`arr[j] = arr[j - gap]`) перемещает элементы внутри подмассива
- **Финальная вставка** (`arr[j] = temp`) помещает элемент на правильную позицию в подмассиве

**Временная сложность:**  
O(n^(3/2)) для последовательности Кнута

**Объяснение временной сложности:**  
При использовании последовательности шагов `n/2, n/4, ..., 1` сложность составляет O(n²) в худшем случае. Однако для оптимальных последовательностей (как у Кнута - `1, 4, 13, 40, ...`) количество операций растет пропорционально n¹·⁵. Это происходит потому, что большие шаги быстрее перемещают элементы ближе к их конечным позициям, уменьшая работу на последующих этапах.

---

### Быстрая сортировка (Quick Sort)

**Определение:**  
Алгоритм типа «разделяй и властвуй», который выбирает опорный элемент и перераспределяет другие элементы относительно него: меньшие размещаются слева, большие — справа.

**Анализ:**
- **Рекурсивная функция** (`quick_sort`) разделяет массив и вызывает себя для левой и правой частей
- **Функция разделения** (`partition`) выбирает опорный элемент (`pivot = arr[high]`) - последний элемент массива
- **Основной цикл разделения** (`for j in range(low, high)`) перебирает элементы и перемещает меньшие или равные опорному в левую часть
- **Индекс i** отслеживает позицию, где заканчиваются элементы меньшие или равные опорному
- **Финальный обмен** (`arr[i + 1], arr[high] = arr[high], arr[i + 1]`) помещает опорный элемент на правильную позицию

**Временная сложность:**  
O(n log n) в среднем случае, O(n²) в худшем случае

**Объяснение временной сложности:**  
При сбалансированном разбиении (опорный элемент делит массив пополам) глубина рекурсии составляет O(log n), а на каждом уровне выполняется O(n) операций в функции partition, что дает O(n log n). В худшем случае (уже отсортированный массив при выборе последнего элемента как опорного) глубина рекурсии становится O(n), что приводит к O(n²).

---

### Пирамидальная сортировка (Heap Sort)

**Определение:**  
Алгоритм, который использует структуру данных «двоичная куча». Он сначала преобразует массив в max-кучу, где наибольший элемент находится в корне, затем последовательно извлекает его и перестраивает кучу.

**Анализ:**
- **Построение кучи** (первый цикл `for (int i = n / 2 - 1; i >= 0; i--)`) вызывает `heapify` для всех нелистовых узлов, начиная с последнего родителя
- **Функция heapify** рекурсивно обеспечивает выполнение свойства кучи, перемещая большие элементы вверх
- **Основной цикл сортировки** (второй цикл `for (int i = n - 1; i > 0; i--)`) извлекает максимальный элемент (корень) и помещает его в конец массива
- **Перестановка элементов** (`arr[0] = arr[i]; arr[i] = temp`) перемещает корень в отсортированную часть
- **Перестройка кучи** (`heapify(arr, i, 0)`) вызывается для уменьшенной кучи после каждого извлечения

**Временная сложность:**  
O(n log n)

**Объяснение временной сложности:**  
Построение кучи выполняется за O(n) операций, так как большинство вызовов `heapify` обрабатывают небольшие поддеревья. Затем выполняется n-1 извлечение максимального элемента, каждое из которых требует O(log n) операций для перестройки кучи. Итоговая сложность: O(n) + O(n log n) = O(n log n).

---

## Алгоритмы поиска

### Линейный поиск (Linear Search)

**Определение:**  
Простой алгоритм, который последовательно проверяет каждый элемент массива до тех пор, пока не найдет искомый элемент или не достигнет конца массива.

**Анализ:**
- **Цикл for** (`for i in range(len(arr))`) последовательно перебирает все элементы массива от начала до конца
- **Операция сравнения** (`if arr[i] == target`) выполняется для каждого элемента до нахождения совпадения
- **Возврат индекса** (`return i`) происходит сразу при нахождении целевого элемента
- **Возврат -1** (`return -1`) выполняется только если элемент не найден после полного прохода по массиву

**Временная сложность:**  
O(n)

**Объяснение временной сложности:**  
В худшем случае (элемент отсутствует или находится в конце) алгоритм выполняет n сравнений. В лучшем случае (элемент в начале) - 1 сравнение. Среднее количество сравнений - n/2. Все случаи асимптотически оцениваются как O(n), так как время выполнения линейно зависит от размера массива.

---

### Бинарный поиск (Binary Search)

**Определение:**  
Алгоритм для поиска элемента в отсортированном массиве, который на каждом шаге делит область поиска пополам.

**Анализ:**
- **Инициализация границ** (`left = 0`, `right = arr.size() - 1`) задает начальную область поиска - весь массив
- **Цикл while** (`while (left <= right)`) продолжается пока область поиска не пуста
- **Вычисление середины** (`mid = left + (right - left) / 2`) находит средний элемент без риска переполнения
- **Проверка совпадения** (`if (arr[mid] == target)`) завершает поиск при нахождении элемента
- **Сужение области** изменяет `left` или `right` в зависимости от сравнения элемента с целевым значением

**Временная сложность:**  
O(log n)

**Объяснение временной сложности:**  
На каждой итерации размер области поиска уменьшается вдвое. После k итераций размер области составляет n/2^k. Поиск завершается когда n/2^k = 1, откуда k = log₂n. Таким образом, количество итераций логарифмически зависит от n.

---

### Интерполяционный поиск (Interpolation Search)

**Определение:**  
Алгоритм поиска в отсортированном массиве, который использует значения элементов для предсказания позиции искомого элемента.

**Анализ:**
- **Инициализация границ** (`low = 0`, `high = arr.length - 1`) задает начальную область поиска
- **Условие продолжения** (`while (low <= high && target >= arr[low] && target <= arr[high])`) проверяет валидность границ и нахождение цели в диапазоне
- **Формула интерполяции** вычисляет предполагаемую позицию `pos` на основе линейной интерполяции между значениями на границах
- **Сравнение и сужение области** аналогично бинарному поиску, но с более точным предсказанием позиции

**Временная сложность:**  
O(log log n) при равномерном распределении данных

**Объяснение временной сложности:**  
При равномерном распределении данных формула интерполяции очень точно предсказывает позицию элемента. На каждой итерации область поиска сокращается экспоненциально, что приводит к двойному логарифмическому времени работы. Однако в худшем случае (неравномерное распределение) сложность может деградировать до O(n).

---

### Поиск Фибоначчи (Fibonacci Search)

**Определение:**  
Алгоритм поиска в отсортированном массиве, который использует числа Фибоначчи для определения точек разделения массива.

**Анализ:**
- **Инициализация чисел Фибоначчи** (`fib_m2 = 0`, `fib_m1 = 1`, `fib_m = fib_m2 + fib_m1`) начинается с первых чисел последовательности
- **Поиск подходящего числа Фибоначчи** (первый цикл `while fib_m < n`) находит наименьшее число Фибоначчи, большее или равное размеру массива
- **Основной цикл поиска** (второй цикл `while fib_m > 1`) использует числа Фибоначчи для определения позиции сравнения
- **Вычисление индекса** (`i = min(offset + fib_m2, n - 1)`) определяет позицию для сравнения на основе чисел Фибоначчи
- **Обновление чисел Фибоначчи** в зависимости от результата сравнения сужает область поиска

**Временная сложность:**  
O(log n)

**Объяснение временной сложности:**  
Так как числа Фибоначчи растут экспоненциально (Fₖ ≈ φᵏ/√5, где φ - золотое сечение), количество чисел Фибоначчи, не превышающих n, составляет O(log n). На каждой итерации алгоритм уменьшает размер области поиска, используя свойства последовательности Фибоначчи, что гарантирует не более O(log n) сравнений.

---
Мартыненко Д.А. УИБО-14-24
